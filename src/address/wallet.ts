import {
    XPrv,
    PrivateKey,
    NetworkType,
    Address,
    PublicKey,
    XOnlyPublicKey,
    signMessage,
    verifyMessage, HexString
} from '../../wasm/kaspa';
import { Mnemonic } from "./mnemonic";
import { WalletType } from "@/utils/enum";
import {Address as AddressUtil} from "@/utils/address";

const DERIVE_PATH = `m/44'/111111'/0'/0/`; // Default derivation path for Kaspa wallets

class Wallet {
    private privateKey: PrivateKey;
    private walletType?: WalletType;
    private xprv?: XPrv;
    private index?: number;

    /**
     * Private constructor to initialize a Wallet instance.
     * @param {PrivateKey} privateKey - The private key for the wallet.
     * @param {WalletType} [walletType] - The type of the wallet (HD or PrivateKey).
     * @param {XPrv} [xprv] - The extended private key (only for HD wallets).
     * @param {number} [index] - The index of the derived key (only for HD wallets).
     */
    private constructor(privateKey: PrivateKey, walletType?: WalletType, xprv?: XPrv, index?: number) {
        this.privateKey = privateKey;
        this.walletType = walletType;
        this.xprv = xprv;
        this.index = index;
    }

    /**
     * Creates a new wallet instance from a mnemonic phrase.
     * @param {string} mnemonic - The mnemonic phrase.
     * @param {string} [password=""] - An optional password for additional security.
     * @returns {Wallet} - A new Wallet instance.
     */
    public static fromMnemonic(mnemonic: string, password: string = ""): Wallet {
        const seed = Mnemonic.toSeed(mnemonic, password);
        const xprv = new XPrv(seed);
        const index = 0;
        const privateKey = xprv.derivePath(`${DERIVE_PATH}${index}`).toPrivateKey();
        return new Wallet(privateKey, WalletType.HD, xprv, index);
    }

    /**
     * Creates a wallet instance from an existing private key.
     * @param {string} privateKey - The private key string.
     * @returns {Wallet} - A new Wallet instance.
     */
    public static fromPrivateKey(privateKey: string): Wallet {
        return new Wallet(new PrivateKey(privateKey), WalletType.PrivateKey);
    }

    /**
     * Returns the private key of the wallet as a string.
     * @returns {string} - The private key.
     */
    public toPrivateKey(): string {
        return this.privateKey.toString();
    }

    /**
     * Returns the public key derived from the private key.
     * @returns {PublicKey} - The public key.
     */
    public toPublicKey(): PublicKey {
        return this.privateKey.toPublicKey();
    }

    /**
     * Returns the X-only public key (compressed public key format).
     * @returns {XOnlyPublicKey} - The X-only public key.
     */
    public toXOnlyPublicKey(): XOnlyPublicKey {
        return this.privateKey.toPublicKey().toXOnlyPublicKey();
    }

    /**
     * Returns the wallet's address based on the specified network type.
     * @param {NetworkType} network - The network type (mainnet, testnet, etc.).
     * @returns {Address} - The corresponding blockchain address.
     */
    public toAddress(network: NetworkType): Address {
        return this.privateKey.toPublicKey().toAddress(network);
    }

    /**
     * Creates a new wallet derived from the current HD wallet at a specified index.
     * @param {number} [index] - The index for the new wallet. If not provided, increments the last index.
     * @returns {Wallet} - A new derived Wallet instance.
     * @throws {Error} - Throws an error if the current wallet is not an HD wallet.
     */
    public newWallet(index?: number): Wallet {
        if (this.walletType !== WalletType.HD) {
            throw new Error("A wallet created from a private key cannot derive new wallets.");
        }

        // If index is not provided, increment the existing index.
        const newIndex = index ?? (this.index! + 1);
        const privateKey = this.xprv!.derivePath(`${DERIVE_PATH}${newIndex}`).toPrivateKey();
        return new Wallet(privateKey, WalletType.HD, this.xprv, newIndex);
    }

    /**
     * Signs a given message using the private key.
     * This allows the owner of the private key to prove ownership of the associated address.
     *
     * @param message - The message to be signed.
     * @returns The signature as a hexadecimal string.
     */
    public signMessage(message: string): HexString {
        return signMessage({
            message: message,
            privateKey: this.privateKey
        });
    }

    /**
     * Verifies a signed message using the public key.
     * This checks whether the signature was generated by the corresponding private key.
     *
     * @param message - The original message that was signed.
     * @param signature - The signature to be verified.
     * @returns A boolean indicating whether the signature is valid.
     */
    public verifyMessage(message: string, signature: string): boolean {
        return verifyMessage({
            message: message,
            signature: signature,
            publicKey: this.privateKey.toPublicKey()
        });
    }

    /**
     * Validates an address.
     * This checks whether the given address is valid using the AddressUtil.
     *
     * @param address - The address to be validated.
     * @returns A boolean indicating whether the address is valid.
     */
    public static validate(address: string): boolean {
        return AddressUtil.validate(address);
    }
}

export { Wallet };
